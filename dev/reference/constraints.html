<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraints · PowerModelsDistribution</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="PowerModelsDistribution logo"/></a><div class="docs-package-name"><span class="docs-autofit">PowerModelsDistribution</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><a class="tocitem" href="../installation.html">Installation Guide</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/quickguide.html">Getting Started</a></li><li><a class="tocitem" href="../manual/external-data-formats.html">External Data Formats</a></li><li><a class="tocitem" href="../manual/eng-data-model.html">Engineering Data Model</a></li><li><a class="tocitem" href="../manual/enums.html">Enums in Engineering Model</a></li><li><a class="tocitem" href="../manual/math-model.html">Mathematical Model</a></li><li><a class="tocitem" href="../manual/eng2math.html">Conversion to Mathematical Model</a></li><li><a class="tocitem" href="../manual/formulations.html">Unbalanced Formulations</a></li><li><a class="tocitem" href="../manual/specifications.html">Problem Specifications</a></li><li><a class="tocitem" href="../manual/load-model.html">Load Models</a></li><li><a class="tocitem" href="../manual/connections.html">Connecting Components</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/Beginners Guide.html">Beginners Guide</a></li><li><a class="tocitem" href="../tutorials/The Engineering Model.html">The Engineering Data Model</a></li><li><a class="tocitem" href="../tutorials/Engineering Model - Helper Functions.html">Engineering Model: Helper Functions</a></li><li><a class="tocitem" href="../tutorials/basic.html">Basics</a></li><li><a class="tocitem" href="../tutorials/Extension Tutorial.html">Extending PowerModelsDistribution</a></li><li><a class="tocitem" href="../tutorials/Explicit Neutral Models.html">Explicit Neutral Models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="base.html">Base</a></li><li><a class="tocitem" href="logging.html">Logging</a></li><li><a class="tocitem" href="data_models.html">Data Models</a></li><li><a class="tocitem" href="enums.html">Enums</a></li><li><a class="tocitem" href="formulations.html">Formulations</a></li><li><a class="tocitem" href="problems.html">Problems</a></li><li><a class="tocitem" href="variables.html">Variables</a></li><li class="is-active"><a class="tocitem" href="constraints.html">Constraints</a><ul class="internal"><li><a class="tocitem" href="#Relaxation-Helpers"><span>Relaxation Helpers</span></a></li><li><a class="tocitem" href="#Miscellaneous-Helpers"><span>Miscellaneous Helpers</span></a></li></ul></li><li><a class="tocitem" href="objectives.html">Objectives</a></li><li><a class="tocitem" href="constants.html">Constants</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../developer/extensions.html">Extensions</a></li><li><a class="tocitem" href="../developer/contributing.html">Contributing</a></li><li><a class="tocitem" href="../developer/style.html">Style Guide</a></li><li><a class="tocitem" href="../developer/roadmap.html">Roadmap</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="constraints.html">Constraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="constraints.html">Constraints</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/master/docs/src/reference/constraints.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ConstraintAPI"><a class="docs-heading-anchor" href="#ConstraintAPI">Constraints</a><a id="ConstraintAPI-1"></a><a class="docs-heading-anchor-permalink" href="#ConstraintAPI" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_M_psd-Tuple{JuMP.Model, Any, Any}" href="#PowerModelsDistribution.constraint_M_psd-Tuple{JuMP.Model, Any, Any}"><code>PowerModelsDistribution.constraint_M_psd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For rectangular coordinates of a complex matrix M=M<em>re+im*M</em>im, this function applies constraints equivalent to requiring that M itself is PSD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L860-L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_SWL_psd-Tuple{JuMP.Model, Any, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_SWL_psd-Tuple{JuMP.Model, Any, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_SWL_psd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Take a multi-conductor voltage variable V and a current variable I. The associated power is then defined as S = V<em>I^H Define the lifted variables as W and L as W = V</em>V^H, L = I*I^H Then, it is equally valid that [W S; S^H L] ∈ PSDCone, rank([W S; S^H L])=1 This function adds this PSD constraint for the rectangular coordinates of S, W and L.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L843-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{AbstractUnbalancedACPModel, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{AbstractUnbalancedACPModel, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_capacitor_on_off(pm::AbstractUnbalancedACPModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching</p><p class="math-container">\[\begin{align}
&amp;\text{kvar control (ON): }  q-q_\text{on} ≤ M_q ⋅ z - ϵ ⋅ (1-z), \\
&amp;\text{kvar control (OFF): } q-q_\text{off} ≥ -M_q ⋅ (1-z) - ϵ ⋅ z, \\
&amp;\text{voltage control (ON): }  v-v_\text{min} ≥ -M_v ⋅ z + ϵ ⋅ (1-z), \\
&amp;\text{voltage control (OFF): } v-v_\text{max} ≤ M_v ⋅ (1-z) - ϵ ⋅ z.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L578-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_capacitor_on_off(pm::AbstractUnbalancedACRModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching</p><p class="math-container">\[\begin{align}
&amp;\text{kvar control (ON): }  q-q_\text{on} ≤ M_q ⋅ z - ϵ ⋅ (1-z), \\
&amp;\text{kvar control (OFF): } q-q_\text{off} ≥ -M_q ⋅ (1-z) - ϵ ⋅ z, \\
&amp;\text{voltage control (ON): }  v_r^2 + v_i^2 - v_\text{min}^2 ≥ -M_v ⋅ z + ϵ ⋅ (1-z), \\
&amp;\text{voltage control (OFF): } v_r^2 + v_i^2 - v_\text{max}^2 ≤ M_v ⋅ (1-z) - ϵ ⋅ z.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L615-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{FBSUBFPowerModel, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{FBSUBFPowerModel, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_capacitor_on_off(pm::FBSUBFPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching</p><p class="math-container">\[\begin{align}
&amp;\text{kvar control (ON): }  q-q_\text{on} ≤ M_q ⋅ z - ϵ ⋅ (1-z), \\
&amp;\text{kvar control (OFF): } q-q_\text{off} ≥ -M_q ⋅ (1-z) - ϵ ⋅ z, \\
&amp;\text{voltage control (ON): }  2 ⋅ v_{r0} ⋅ v_r + 2 ⋅ v_{i0} ⋅ v_i - v_{r0}^2 - v_{i0}^2 - v_\text{min}^2 ≥ -M_v ⋅ z + ϵ ⋅ (1-z), \\
&amp;\text{voltage control (OFF): } 2 ⋅ v_{r0} ⋅ v_r + 2 ⋅ v_{i0} ⋅ v_i - v_{r0}^2 - v_{i0}^2 - v_\text{max}^2 ≤ M_v ⋅ (1-z) - ϵ ⋅ z.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L438-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{FOTRUPowerModel, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{FOTRUPowerModel, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_capacitor_on_off(pm::FOTRUPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching similar to FBSUBFPowerModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotr.jl#L333-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_capacitor_on_off-Tuple{LPUBFDiagModel, Int64, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_capacitor_on_off-Tuple{LPUBFDiagModel, Int64, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_capacitor_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_capacitor_on_off(pm::LPUBFDiagModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Add constraints to model capacitor switching</p><p class="math-container">\[\begin{align}
&amp;\text{kvar control (ON): }  q-q_\text{on} ≤ M_q ⋅ z - ϵ ⋅ (1-z), \\
&amp;\text{kvar control (OFF): } q-q_\text{off} ≥ -M_q ⋅ (1-z) - ϵ ⋅ z, \\
&amp;\text{voltage control (ON): }  w - v_\text{min}^2 ≥ -M_v ⋅ z + ϵ ⋅ (1-z), \\
&amp;\text{voltage control (OFF): } w - v_\text{max}^2 ≤ M_v ⋅ (1-z) - ϵ ⋅ z.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_lin.jl#L275-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ampacity_from(pm::AbstractUnbalancedACPModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches from-side</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq vm_{fr}^2 i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1256-L1264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ampacity_from(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for branch current limit constraint from-side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L1026-L1030">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ampacity_from(pm::AbstractUnbalancedRectangularModels, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches from-side</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq (vr_{fr}^2 + vi_{fr}^2) i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L1119-L1127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ampacity_from-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ampacity_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ampacity_from(pm::AbstractUnbalancedWModels, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches from-side</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq w_{fr} i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L380-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ampacity_to(pm::AbstractUnbalancedACPModel, nw::Int, t_idx::Tuple{Int,Int,Int}, t_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches to-side</p><p>math<code>p_{to}^2 + q_{to}^2 \leq vm_{to}^2 i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1280-L1288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ampacity_to(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothin</code></pre><p>Template function for branch current limit constraint to-side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L1046-L1050">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ampacity_to(pm::AbstractUnbalancedRectangularModels, nw::Int, t_idx::Tuple{Int,Int,Int}, t_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches to-side</p><p>math<code>p_{to}^2 + q_{to}^2 \leq (vr_{to}^2 + vi_{to}^2) i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L1145-L1153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ampacity_to-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ampacity_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ampacity_to(pm::AbstractUnbalancedWModels, nw::Int, t_idx::Tuple{Int,Int,Int}, t_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on branches to-side</p><p>math<code>p_{to}^2 + q_{to}^2 \leq w_{to} i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L404-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{T} where T, Vector{T} where T, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{T} where T, Vector{T} where T, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_branch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_branch_current_limit(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector,
	t_connections::Vector,
	c_rating::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the total current magnitude per conductor.</p><pre><code class="language-none">p_fr^2 + q_fr^2 &lt;= r^2 * (vr_fr^2 + vi_fr^2)
p_to^2 + q_to^2 &lt;= r^2 * (vr_to^2 + vi_to^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L627-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{T} where T, Vector{T} where T, Vector{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{T} where T, Vector{T} where T, Vector{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_branch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_branch_current_limit(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector,
	t_connections::Vector,
	c_rating::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, imposes a bound on the current magnitude per conductor at both ends of the branch (total current, i.e. including shunt contributions).</p><pre><code class="language-none">cr_fr^2 + ci_fr^2 &lt;= c_rating^2
cr_to^2 + ci_to^2 &lt;= c_rating^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1392-L1412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_branch_current_limit-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_branch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_branch_current_limit(
	pm::ExplicitNeutralModels,
	id::Int;
	nw::Int=nw_id_default,
	bounded::Bool=true,
	report::Bool=true,
	kwargs...
)</code></pre><p>For models with explicit neutrals, imposes a bound on the current magnitude per conductor  at both ends of the branch (total current, i.e. including shunt contributions)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_shared.jl#L923-L936">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_branch_current_series_product_hermitian-Tuple{AbstractUBFModels}" href="#PowerModelsDistribution.constraint_mc_branch_current_series_product_hermitian-Tuple{AbstractUBFModels}"><code>PowerModelsDistribution.constraint_mc_branch_current_series_product_hermitian</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_balance-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_balance-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_bus_voltage_balance(pm::AbstractUnbalancedPowerModel, bus_id::Int; nw=nw_id_default)::Nothing</code></pre><p>Template function for bus voltage balance constraints.</p><p>Impose all balance related constraints for which key present in data model of bus. For a discussion of sequence components and voltage unbalance factor (VUF), see @INPROCEEDINGS{girigoudar<em>molzahn</em>roald-2019, 	author={K. Girigoudar and D. K. Molzahn and L. A. Roald}, 	booktitle={submitted}, 	title={{Analytical and Empirical Comparisons of Voltage Unbalance Definitions}}, 	year={2019}, 	month={},     url={https://molzahn.github.io/pubs/girigoudar<em>molzahn</em>roald-2019.pdf} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_drop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_bus_voltage_drop(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	i::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	r::Matrix{&lt;:Real},
	x::Matrix{&lt;:Real}
)</code></pre><p>For IVR models with explicit neutrals, defines voltage drop over a branch, linking from and to side complex voltage.</p><pre><code class="language-none">vr_to == vr_fr - r*csr_fr + x*csi_fr
vi_to == vi_fr - r*csi_fr - x*csr_fr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1355-L1376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_drop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines voltage drop over a branch, linking from and to side complex voltage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_drop-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_drop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_bus_voltage_drop(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for bus voltage drop constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L642-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_ll-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{T} where T, Vector{T} where T}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_ll-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{T} where T, Vector{T} where T}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_ll</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_negative_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Float64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_negative_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Float64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_negative_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>a = exp(im<em>2π/3) U+ = (1</em>Ua + a<em>Ub a^2</em>Uc)/3 U- = (1<em>Ua + a^2</em>Ub a<em>Uc)/3 vuf = |U-|/|U+| |U-| &lt;= vufmax</em>|U+| |U-|^2 &lt;= vufmax^2*|U+|^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L862-L869">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off bus voltage magnitude constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{var&quot;#s782&quot;} where var&quot;#s782&quot;&lt;:Real, Vector{var&quot;#s781&quot;} where var&quot;#s781&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{var&quot;#s782&quot;} where var&quot;#s782&quot;&lt;:Real, Vector{var&quot;#s781&quot;} where var&quot;#s781&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_bus_voltage_magnitude_on_off(pm::AbstractUnbalancedPowerModel, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})::Nothing</code></pre><p>Generic on/off bus voltage magnitude constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_bus_voltage_magnitude_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for on/off voltage magnitude constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_positive_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Float64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_positive_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Float64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_positive_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>a = exp(im<em>2π/3) U+ = (1</em>Ua + a<em>Ub a^2</em>Uc)/3 U- = (1<em>Ua + a^2</em>Ub a<em>Uc)/3 vuf = |U-|/|U+| |U-| &lt;= vufmax</em>|U+| |U-|^2 &lt;= vufmax^2*|U+|^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L897-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{var&quot;#s782&quot;} where var&quot;#s782&quot;&lt;:Real, Vector{var&quot;#s781&quot;} where var&quot;#s781&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{var&quot;#s782&quot;} where var&quot;#s782&quot;&lt;:Real, Vector{var&quot;#s781&quot;} where var&quot;#s781&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off bus voltage magnitude squared constraint for relaxed formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_sqr_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_bus_voltage_magnitude_sqr_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for on/off voltage magnitude squared constraint for relaxed formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_vuf-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Float64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_vuf-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Float64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_vuf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>a = exp(im<em>2π/3) U+ = (1</em>Ua + a<em>Ub a^2</em>Uc)/3 U- = (1<em>Ua + a^2</em>Ub a<em>Uc)/3 vuf = |U-|/|U+| |U-| &lt;= vufmax</em>|U+| |U-|^2 &lt;= vufmax^2*|U+|^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L815-L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_zero_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Float64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_zero_sequence-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Float64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_magnitude_zero_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>a = exp(im<em>2π/3) U+ = (1</em>Ua + a<em>Ub a^2</em>Uc)/3 U- = (1<em>Ua + a^2</em>Ub a<em>Uc)/3 vuf = |U-|/|U+| |U-| &lt;= vufmax</em>|U+| |U-|^2 &lt;= vufmax^2*|U+|^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L932-L939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedACPModel}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedACPModel}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>bus voltage on/off constraint for load shed problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1034">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedACRModel}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedACRModel}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>bus voltage on/off constraint for load shed problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedDCPModel}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedDCPModel}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off bus voltage constraint for DCP formulation, nothing to do</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/dcp.jl#L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_bus_voltage_on_off(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, kwargs...)::Nothing</code></pre><p>Template function for on/off constraint for bus voltages&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedWModels, Int64}" href="#PowerModelsDistribution.constraint_mc_bus_voltage_on_off-Tuple{AbstractUnbalancedWModels, Int64}"><code>PowerModelsDistribution.constraint_mc_bus_voltage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off bus voltage constraint for relaxed forms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_balance-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_current_balance-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_current_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Kirchhoff&#39;s current law applied to buses <code>sum(cr + im*ci) = 0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L246-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_balance-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_current_balance-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_current_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_current_balance(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints in current-voltage variable space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L377-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_balance-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_current_balance-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_current_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_current_balance(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	terminals::Vector{Int},
	grounded::Vector{Bool},
	bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_gens::Vector{Tuple{Int,Vector{Int}}},
	bus_storage::Vector{Tuple{Int,Vector{Int}}},
	bus_loads::Vector{Tuple{Int,Vector{Int}}},
	bus_shunts::Vector{Tuple{Int,Vector{Int}}}
)</code></pre><p>Kirchhoff&#39;s current law applied to buses <code>sum(cr + im*ci) = 0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_shared.jl#L96-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Matrix{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Matrix{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_current_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_current_from(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	f_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	g_sh_fr::Matrix{&lt;:Real},
	b_sh_fr::Matrix{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, defines how current distributes over series and shunt impedances of a pi-model branch.</p><pre><code class="language-none">cr_fr == csr_fr + g_sh_fr*vr_fr - b_sh_fr*vi_fr
ci_fr == csi_fr + g_sh_fr*vi_fr + b_sh_fr*vr_fr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1266-L1285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_current_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines how current distributes over series and shunt impedances of a pi-model branch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractUnbalancedIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_current_from-Tuple{AbstractUnbalancedIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_current_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_current_from(pm::AbstractUnbalancedIVRModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for current constraints on branches (from-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L603-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_from-Tuple{ReducedExplicitNeutralIVRModels, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Matrix{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_current_from-Tuple{ReducedExplicitNeutralIVRModels, Int64, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Matrix{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_current_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_current_from(
	pm::ReducedExplicitNeutralIVRModels,
	nw::Int,
	f_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	g_sh_fr::Matrix{&lt;:Real},
	b_sh_fr::Matrix{&lt;:Real};
	report::Bool=true
)</code></pre><p>For branch-reduced IVR models with explicit neutrals, defines how current distributes over series and shunt impedances of a pi-model branch.</p><pre><code class="language-none">cr_fr = csr_fr + g_sh_fr*vr_fr - b_sh_fr*vi_fr
ci_fr = csi_fr + g_sh_fr*vi_fr + b_sh_fr*vr_fr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1530-L1549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_limit-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_current_limit-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bounds the current magnitude at both from and to side of a branch <code>cr[f_idx]^2 + ci[f_idx]^2 &lt;= c_rating_a^2</code> <code>cr[t_idx]^2 + ci[t_idx]^2 &lt;= c_rating_a^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L330-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractExplicitNeutralIVRModel, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Matrix{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractExplicitNeutralIVRModel, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Matrix{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_current_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_current_to(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	t_bus,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	g_sh_to::Matrix{&lt;:Real},
	b_sh_to::Matrix{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, defines how current distributes over series and shunt impedances of a pi-model branch.</p><pre><code class="language-none">cr_to == csr_to + g_sh_to*vr_to - b_sh_to*vi_to
ci_to == csi_to + g_sh_to*vi_to + b_sh_to*vr_to</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1310-L1331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_current_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines how current distributes over series and shunt impedances of a pi-model branch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractUnbalancedIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_current_to-Tuple{AbstractUnbalancedIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_current_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_current_to(pm::AbstractUnbalancedIVRModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for current constraints on branches (to-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L622-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_current_to-Tuple{ReducedExplicitNeutralIVRModels, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Matrix{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_current_to-Tuple{ReducedExplicitNeutralIVRModels, Int64, Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Matrix{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_current_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_current_to(
	pm::ReducedExplicitNeutralIVRModels,
	nw::Int,
	t_bus,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	g_sh_to::Matrix{&lt;:Real},
	b_sh_to::Matrix{&lt;:Real};
	report::Bool=true
)</code></pre><p>For branch-reduced IVR models with explicit neutrals, defines how current distributes over series and shunt impedances of a pi-model branch.</p><pre><code class="language-none">cr_to = csr_to + g_sh_to*vr_to - b_sh_to*vi_to
ci_to = csi_to + g_sh_to*vi_to + b_sh_to*vr_to</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1575-L1596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_active_bounds-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_gen_active_bounds-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_gen_active_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>pmin &lt;= Re(v*cg&#39;) &lt;= pmax</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L350-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_active_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_gen_active_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_gen_active_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_gen_active_bounds(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for defining limits on active power output of a generator where bounds can&#39;t be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L860-L864">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real, Vector{var&quot;#s2970&quot;} where var&quot;#s2970&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real, Vector{var&quot;#s2970&quot;} where var&quot;#s2970&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_gen_power_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off constraint for generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{var&quot;#s783&quot;} where var&quot;#s783&quot;&lt;:Int64, Vector{var&quot;#s782&quot;} where var&quot;#s782&quot;&lt;:Real, Vector{var&quot;#s781&quot;} where var&quot;#s781&quot;&lt;:Real, Vector{var&quot;#s780&quot;} where var&quot;#s780&quot;&lt;:Real, Vector{var&quot;#s774&quot;} where var&quot;#s774&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{var&quot;#s783&quot;} where var&quot;#s783&quot;&lt;:Int64, Vector{var&quot;#s782&quot;} where var&quot;#s782&quot;&lt;:Real, Vector{var&quot;#s781&quot;} where var&quot;#s781&quot;&lt;:Real, Vector{var&quot;#s780&quot;} where var&quot;#s780&quot;&lt;:Real, Vector{var&quot;#s774&quot;} where var&quot;#s774&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_gen_power_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>on/off constraint for generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_gen_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_gen_power_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_gen_power_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for generator power on/off constraints (MLD problems)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L841-L845">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_gen_power_setpoint_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>pg[i] == pg</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_gen_power_setpoint_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_gen_power_setpoint_real(pm::AbstractUnbalancedPowerModel, nw::Int, i::Int, pg::Vector{&lt;:Real})::Nothing</code></pre><p>Generic generator real power setpoint constraint</p><p class="math-container">\[P_g == P_g^{setpoint}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L89-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_gen_power_setpoint_real-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_gen_power_setpoint_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_gen_power_setpoint_real(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for generator active power setpoint constraint, for power flow problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L829-L833">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_reactive_bounds-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_gen_reactive_bounds-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_gen_reactive_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>qmin &lt;= Im(v*cg&#39;) &lt;= qmax</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L366-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_gen_reactive_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_gen_reactive_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_gen_reactive_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_gen_reactive_bounds(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for defines limits on reactive power output of a generator where bounds can&#39;t be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L873-L877">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_generator_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_generator_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_generator_current(
	pm::AbstractExplicitNeutralIVRModel,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, creates expressions for the terminal current flows <code>:crg_bus</code> and <code>:cig_bus</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L38-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_current_delta-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_generator_current_delta-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_generator_current_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_generator_current_delta(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	connections::Vector{Int};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, creates expressions for the terminal current flows <code>:crg_bus</code> and <code>:cig_bus</code> of delta-connected generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L86-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_current_wye-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_generator_current_wye-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_generator_current_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_generator_current_wye(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	connections::Vector{Int};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, creates expressions for the terminal current flows <code>:crg_bus</code> and <code>:cig_bus</code> of wye-connected generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L65-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power-Tuple{AbstractUnbalancedActivePowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_generator_power-Tuple{AbstractUnbalancedActivePowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_generator_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Only support wye-connected generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_generator_power-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_generator_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_generator_power(pm::AbstractUnbalancedPowerModel, id::Int; nw::Int=nw_id_default, report::Bool=true, bounded::Bool=true)::Nothing</code></pre><p>Template function for generator power constraints</p><p><strong>DELTA</strong></p><p>When connected in delta, the load power gives the reference in the delta reference frame. This means</p><p class="math-container">\[sd_1 = v_ab.conj(i_ab) = (v_a-v_b).conj(i_ab)\]</p><p>We can relate this to the per-phase power by</p><p class="math-container">\[sn_a = v_a.conj(i_a)
    = v_a.conj(i_ab-i_ca)
    = v_a.conj(conj(s_ab/v_ab) - conj(s_ca/v_ca))
    = v_a.(s_ab/(v_a-v_b) - s_ca/(v_c-v_a))\]</p><p>So for delta, sn is constrained indirectly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L785-L809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power-Tuple{SDPUBFKCLMXModel, Int64}" href="#PowerModelsDistribution.constraint_mc_generator_power-Tuple{SDPUBFKCLMXModel, Int64}"><code>PowerModelsDistribution.constraint_mc_generator_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Link the current and power withdrawn by a generator at the bus through a PSD constraint. The rank-1 constraint is dropped in this formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L571-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_generator_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_generator_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_generator_power(
    pm::ExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    report::Bool=true
)</code></pre><p>Constrains generator power variables for models with explicit neutrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template_en.jl#L69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_generator_power_delta(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, links the terminal power flows <code>:pg_bus</code> and <code>:qg_bus</code> to the power variables <code>:pg</code> and <code>:qg</code> for delta-connected generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L86-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_generator_power_delta(
	pm::AbstractNLExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, creates non-linear expressions for the generator power <code>:pd</code> and <code>:qd</code> of delta-connected generators as a function of voltage and current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L170-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_generator_power_delta(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, links the generator power variables <code>:pd</code> and <code>:qd</code> of delta-connected generators to the voltage and current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L266-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real, Vector{var&quot;#s2954&quot;} where var&quot;#s2954&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real, Vector{var&quot;#s2954&quot;} where var&quot;#s2954&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L901">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_delta-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delta connected generator setpoint constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_generator_power_wye(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, links the terminal power flows <code>:pg_bus</code> and <code>:qg_bus</code> to the power variables <code>:pg</code> and <code>:qg</code> for wye-connected generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L26-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_generator_power_wye(
	pm::AbstractNLExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, creates non-linear expressions for the generator power <code>:pd</code> and <code>:qd</code> of wye-connected generators as a function of voltage and current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L110-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Vector{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real, Vector{var&quot;#s2964&quot;} where var&quot;#s2964&quot;&lt;:Real, Vector{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Vector{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real, Vector{var&quot;#s2964&quot;} where var&quot;#s2964&quot;&lt;:Real, Vector{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_generator_power_wye(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	pmin::Vector{&lt;:Real},
	pmax::Vector{&lt;:Real},
	qmin::Vector{&lt;:Real},
	qmax::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, links the generator power variables <code>:pd</code> and <code>:qd</code> of wye-connected generators to the voltage and current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L227-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Vector{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real, Vector{var&quot;#s2964&quot;} where var&quot;#s2964&quot;&lt;:Real, Vector{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Vector{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real, Vector{var&quot;#s2964&quot;} where var&quot;#s2964&quot;&lt;:Real, Vector{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_generator_power_wye-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_generator_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><p>wye connected generator setpoint constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_current(
	pm::AbstractExplicitNeutralIVRModel,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, create non-linear expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L459-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_current-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_current(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, create expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L779-L790">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_current_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_current_delta(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	a::Vector{&lt;:Real},
	alpha::Vector{&lt;:Real},
	b::Vector{&lt;:Real},
	beta::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, create non-linear expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code> of delta-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L564-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_load_current_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_current_delta(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	connections::Vector{Int};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, create expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code> for delta-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L828-L841">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{T} where T, Vector{T} where T}" href="#PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{T} where T, Vector{T} where T}"><code>PowerModelsDistribution.constraint_mc_load_current_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>We want to express s<em>ab = cp.|v</em>ab|+im.cq.|v<em>ab| i</em>ab = conj(s<em>ab/v</em>ab) = |v<em>ab|.(cq-im.cq)/conj(v</em>ab) = (1/|v<em>ab|).(cp-im.cq)*v</em>ab idem for i<em>bc and i</em>ca And then s<em>a = v</em>a.conj(i<em>a) = v</em>a.conj(i<em>ab-i</em>ca) idem for s<em>b and s</em>c</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L961-L969">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Vector{T} where T, Vector{T} where T}" href="#PowerModelsDistribution.constraint_mc_load_current_delta-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Vector{T} where T, Vector{T} where T}"><code>PowerModelsDistribution.constraint_mc_load_current_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_load_current_delta(pm::FOTPUPowerModel, nw::Int, load_id::Int, load_bus_id::Int, cp::Vector, cq::Vector)</code></pre><p>No loads require a current variable. Delta loads are zero-order approximations and wye loads are first-order approximations around the initial operating point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotp.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_wye-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_current_wye-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_current_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_current_wye(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	a::Vector{&lt;:Real},
	alpha::Vector{&lt;:Real},
	b::Vector{&lt;:Real},
	beta::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, create non-linear expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code> of wye-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L487-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_current_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_load_current_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_load_current_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_current_wye(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	connections::Vector{Int};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, create expressions for the terminal current flows <code>:crd_bus</code> and <code>:cid_bus</code> for wye-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L806-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_power(
	pm::AbstractExplicitNeutralIVRModel,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, the load power does not require any constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L444-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_power(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, link the load power variables <code>:pd</code> and <code>:qd</code> to the voltage, and link together the power, voltage and current variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L628-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUBFModels, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUBFModels, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates the constraints modelling the (relaxed) voltage-dependent loads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L652-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUnbalancedActivePowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUnbalancedActivePowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Only support wye-connected, constant-power loads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_load_power(pm::AbstractUnbalancedPowerModel, id::Int; nw::Int=nw_id_default, report::Bool=true)::Nothing</code></pre><p>Template function for load constraints.</p><p><strong>CONSTANT POWER</strong></p><p>Fixes the load power sd.</p><p class="math-container">\[sd = [sd_1, sd_2, sd_3]\]</p><p>What is actually fixed, depends on whether the load is connected in delta or wye. When connected in wye, the load power equals the per-phase power sn drawn at the bus to which the load is connected.</p><p class="math-container">\[sd_1 = v_a.conj(i_a) = sn_a\]</p><p><strong>CONSTANT CURRENT</strong></p><p>Sets the active and reactive load power sd to be proportional to the the voltage magnitude.</p><p class="math-container">\[pd = cp.|vm|
qd = cq.|vm|
sd = cp.|vm| + j.cq.|vm|\]</p><p><strong>CONSTANT IMPEDANCE</strong></p><p>Sets the active and reactive power drawn by the load to be proportional to the square of the voltage magnitude.</p><p class="math-container">\[pd = cp.|vm|^2
qd = cq.|vm|^2
sd = cp.|vm|^2 + j.cq.|vm|^2\]</p><p><strong>DELTA</strong></p><p>When connected in delta, the load power gives the reference in the delta reference frame. This means</p><p class="math-container">\[sd_1 = v_ab.conj(i_ab) = (v_a-v_b).conj(i_ab)\]</p><p>We can relate this to the per-phase power by</p><p class="math-container">\[sn_a = v_a.conj(i_a)
    = v_a.conj(i_ab-i_ca)
    = v_a.conj(conj(s_ab/v_ab) - conj(s_ca/v_ca))
    = v_a.(s_ab/(v_a-v_b) - s_ca/(v_c-v_a))\]</p><p>So for delta, sn is constrained indirectly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L703-L765">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{FBSUBFPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{FBSUBFPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_load_power(pm::FBSUBFPowerModel, load_id::Int; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Load model is linearized around initial operating point. Wye loads are first-order and delta loads are zero-order approximations.</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating point: }  v_{rd}^0 + j ⋅ v_{id}^0~\text{where}~{(v_m^0)}^2 = {(v_{rd}^0)}^2 + {(v_{id}^0)}^2\\
&amp;\text{Constant power: }  P^d = P^{d0},~Q^d = Q^{d0} \\
&amp;\text{Constant impedance: }  P^d = a ⋅ \left(2\cdot v_{rd} ⋅ v_{rd}^0+2 ⋅ v_{id}*v_{id}^0-{(v_{m}^0)}^2\right),\\
&amp;  Q^d = b ⋅ \left(2\cdot v_{rd} ⋅ v_{rd}^0+2 ⋅ v_{id}*v_{id}^0-{(v_{m}^0)}^2\right),  \\
&amp;\text{Constant current: }  P^d = a ⋅ \left(v_{m}^0 + \frac{v_{rd} ⋅ v_{rd}^0+ v_{id}*v_{id}^0-{(v_{m}^0)}^2}{v_{m}^0} \right),\\
&amp; Q^d = b ⋅ \left(v_{m}^0 + \frac{v_{rd} ⋅ v_{rd}^0+ v_{id}*v_{id}^0-{(v_{m}^0)}^2}{v_{m}^0} \right).
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L501-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{FOTPUPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{FOTPUPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_load_power(pm::FOTPUPowerModel, load_id::Int; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Load model is linearized around initial operating point. Wye loads are first-order and delta loads are zero-order approximations.</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating point: }   v_{m0} \angle v_{a0}\\
&amp;\text{Constant power: }  P^d = P^{d0},~Q^d = Q^{d0} \\
&amp;\text{Constant impedance: }  P^d = a \cdot \left({v_{m0}}^2+2 \cdot v_{m0} \cdot (v_m-v_{m0})\right),\\
&amp;  Q^d = b \cdot \left({v_{m0}}^2+2 \cdot v_{m0} \cdot (v_m-v_{m0})\right),  \\
&amp;\text{Constant current: }  P^d = a \cdot v_m,\\
&amp; Q^d = b \cdot v_m.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotp.jl#L417-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{FOTRUPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{FOTRUPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_load_power(pm::FOTRUPowerModel, load_id::Int; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Load model is linearized around initial operating point similar to FBSUBFPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotr.jl#L445-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{LPUBFDiagModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{LPUBFDiagModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_load_power(pm::LPUBFDiagModel, load_id::Int; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Delta/voltage-dependent load models for LPUBFDiagModel. Delta loads use the auxilary power variable (X). The constant current load model is derived by linearizing around the flat-start voltage solution.</p><p class="math-container">\[\begin{align}
&amp;\text{Constant power:} \Rightarrow P_i^d = P_i^{d0},~Q_i^d = Q_i^{d0} ~\forall i \in L \\
&amp;\text{Constant impedance (Wye):} \Rightarrow P_i^d = a_i \cdot w_i,~Q_i^d = b_i \cdot w_i ~\forall i \in L \\
&amp;\text{Constant impedance (Delta):} \Rightarrow P_i^d = 3\cdot a_i \cdot w_i,~Q_i^d = 3\cdot b_i \cdot w_i ~\forall i \in L \\
&amp;\text{Constant current (Wye):} \Rightarrow P_i^d = \frac{a_i}{2}\cdot \left( 1+w_i \right),~Q_i^d = \frac{b_i}{2}\cdot \left( 1+w_i \right) \forall i \in L \\
&amp;\text{Constant current (Delta):} \Rightarrow P_i^d = \frac{\sqrt{3} \cdot a_i}{2}\cdot \left( 1+w_i \right),~Q_i^d = \frac{\sqrt{3} \cdot b_i}{2}\cdot \left( 1+w_i \right) \forall i \in L
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_lin.jl#L356-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{SDPUBFKCLMXModel, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{SDPUBFKCLMXModel, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates the constraints modelling the (relaxed) voltage-dependent loads for the matrix KCL formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L753-L756">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_load_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_power(
	pm::ExplicitNeutralModels,
	id::Int;
	nw::Int=nw_id_default,
	report::Bool=true
)</code></pre><p>Constrains load power variables for models with explicit neutrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template_en.jl#L209-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real, Vector{var&quot;#s2954&quot;} where var&quot;#s2954&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real, Vector{var&quot;#s2954&quot;} where var&quot;#s2954&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_power_delta(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	a::Vector{&lt;:Real},
	alpha::Vector{&lt;:Real},
	b::Vector{&lt;:Real},
	beta::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, creates non-linear expressions for terminal power flows &#39;:pd<em>bus&#39; and &#39;:qd</em>bus&#39; of delta-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L233-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, LoadModel, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, LoadModel, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_power_delta(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	model::LoadModel,
	a::Vector{&lt;:Real},
	b::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, link the load power variables <code>:pd</code> and <code>:qd</code> to the voltage, and link together the power, voltage and current variables for delta-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L719-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2952&quot;} where var&quot;#s2952&quot;&lt;:Real, Vector{var&quot;#s2951&quot;} where var&quot;#s2951&quot;&lt;:Real, Vector{var&quot;#s2950&quot;} where var&quot;#s2950&quot;&lt;:Real, Vector{var&quot;#s2949&quot;} where var&quot;#s2949&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2952&quot;} where var&quot;#s2952&quot;&lt;:Real, Vector{var&quot;#s2951&quot;} where var&quot;#s2951&quot;&lt;:Real, Vector{var&quot;#s2950&quot;} where var&quot;#s2950&quot;&lt;:Real, Vector{var&quot;#s2949&quot;} where var&quot;#s2949&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2952&quot;} where var&quot;#s2952&quot;&lt;:Real, Vector{var&quot;#s2951&quot;} where var&quot;#s2951&quot;&lt;:Real, Vector{var&quot;#s2950&quot;} where var&quot;#s2950&quot;&lt;:Real, Vector{var&quot;#s2949&quot;} where var&quot;#s2949&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2952&quot;} where var&quot;#s2952&quot;&lt;:Real, Vector{var&quot;#s2951&quot;} where var&quot;#s2951&quot;&lt;:Real, Vector{var&quot;#s2950&quot;} where var&quot;#s2950&quot;&lt;:Real, Vector{var&quot;#s2949&quot;} where var&quot;#s2949&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L831">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Vector{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real, Vector{var&quot;#s2964&quot;} where var&quot;#s2964&quot;&lt;:Real, Vector{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_power_delta-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Vector{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real, Vector{var&quot;#s2964&quot;} where var&quot;#s2964&quot;&lt;:Real, Vector{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_power_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delta connected load setpoint constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Vector{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Vector{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_power_wye(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	a::Vector{&lt;:Real},
	alpha::Vector{&lt;:Real},
	b::Vector{&lt;:Real},
	beta::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, creates non-linear expressions for terminal power flows &#39;:pd<em>bus&#39; and &#39;:qd</em>bus&#39; of wye-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L166-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, LoadModel, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Int64, Vector{Int64}, LoadModel, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_load_power_wye(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	bus_id::Int,
	connections::Vector{Int},
	model::LoadModel,
	a::Vector{&lt;:Real},
	b::Vector{&lt;:Real};
	report::Bool=true,
	bounded::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, link the load power variables <code>:pd</code> and <code>:qd</code> to the voltage, and link together the power, voltage and current variables for wye-connected loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L659-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1065">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{var&quot;#s2961&quot;} where var&quot;#s2961&quot;&lt;:Real, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L786">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_load_power_wye-Tuple{IVRUPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Vector{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real, Vector{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Vector{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_load_power_wye</code></a> — <span class="docstring-category">Method</span></header><section><div><p>wye connected load setpoint constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_current-Tuple{AbstractLPUBFModel, Int64, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_mc_model_current-Tuple{AbstractLPUBFModel, Int64, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_mc_model_current</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines relationship between branch (series) power flow, branch (series) current and node voltage magnitude</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_lin.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_current-Tuple{AbstractUBFModels}" href="#PowerModelsDistribution.constraint_mc_model_current-Tuple{AbstractUBFModels}"><code>PowerModelsDistribution.constraint_mc_model_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_model_current(pm::AbstractUBFModels; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for constraints for model current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L503-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_current-Tuple{SDPUBFModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_model_current-Tuple{SDPUBFModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_model_current</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines relationship between branch (series) power flow, branch (series) current and node voltage magnitude</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_sdp.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_current-Tuple{SOCConicUBFModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_model_current-Tuple{SOCConicUBFModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_model_current</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines relationship between branch (series) power flow, branch (series) current and node voltage magnitude</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_soc.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_current-Tuple{SOCUBFModels, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_model_current-Tuple{SOCUBFModels, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Matrix{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_model_current</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines relationship between branch (series) power flow, branch (series) current and node voltage magnitude</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_soc.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedDCPModel, Int64, Int64}" href="#PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedDCPModel, Int64, Int64}"><code>PowerModelsDistribution.constraint_mc_model_voltage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, these models do not have complex voltage constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/dcp.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_model_voltage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>do nothing by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsDistribution.constraint_mc_model_voltage-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsDistribution.constraint_mc_model_voltage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_model_voltage(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for model voltage constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{AbstractUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{AbstractUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines voltage drop over a branch, linking from and to side voltage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_model_voltage_magnitude_difference(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for constraints for modeling voltage magnitude difference across branches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L481-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Matrix{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real, Matrix{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Matrix{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Matrix{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real, Matrix{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Matrix{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_model_voltage_magnitude_difference(pm::FBSUBFPowerModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, r::Matrix{&lt;:Real}, x::Matrix{&lt;:Real}, g_sh_fr::Matrix{&lt;:Real}, b_sh_fr::Matrix{&lt;:Real})</code></pre><p>Voltage drop over a branch linearized around initial operating point (forward sweep)</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating points: }  (v_{r0}^{fr} + j ⋅ v_{i0}^{fr}),~ (v_{r0}^{to} + j ⋅ v_{i0}^{to})\\
&amp;\text{Series active power flow: }  p_s^{fr} =  p^{fr} -  g_{sh}^{fr} ⋅ {(v_{m0}^{fr})}^2,\\
&amp;\text{Series reactive power flow: }  q_s^{fr} =  q^{fr} +  b_{sh}^{fr} ⋅ {(v_{m0}^{fr})}^2,\\
&amp;\text{Series real current flow: }  cr_s^{fr} =  \frac{(p_s^{fr} ⋅ v_{r0}^{fr} + q_s^{fr} ⋅ v_{i0}^{fr})}{{(v_{m0}^{fr})}^2},\\
&amp;\text{Series imaginary current flow: }  ci_s^{fr} =  \frac{(-q_s^{fr} ⋅ v_{r0}^{fr} + p_s^{fr} ⋅ v_{i0}^{fr})}{{(v_{m0}^{fr})}^2},\\
&amp;\text{Series real voltage drop: } v_{r}^{to} = v_{r}^{fr} - r ⋅ cr_s^{fr} + x ⋅ ci_s^{fr} ,\\
&amp;\text{Series imaginary voltage drop: } v_{i}^{to} = v_{i}^{fr} - x ⋅ cr_s^{fr} - r ⋅ ci_s^{fr}.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L200-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Matrix{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real, Matrix{var&quot;#s2964&quot;} where var&quot;#s2964&quot;&lt;:Real, Matrix{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Matrix{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real, Matrix{var&quot;#s2964&quot;} where var&quot;#s2964&quot;&lt;:Real, Matrix{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_model_voltage_magnitude_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines voltage drop over a branch, linking from and to side voltage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_lin.jl#L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_network_power_balance-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Any, Any, Any, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_mc_network_power_balance-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Any, Any, Any, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_mc_network_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_network_power_balance-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_network_power_balance-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_network_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_network_power_balance(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for constraints that ensures that power generation and demand are balanced in OBF problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L397-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_ohms_yt_from(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	G::Matrix{&lt;:Real},
	B::Matrix{&lt;:Real},
	G_fr::Matrix{&lt;:Real},
	B_fr::Matrix{&lt;:Real}
)</code></pre><p>For ACR models with explicit neutrals, creates Ohms constraints for ACR models with explicit neutrals.</p><pre><code class="language-none">s_fr = v_fr.*conj(Y*(v_fr-v_to))
s_fr = (vr_fr+im*vi_fr).*(G-im*B)*([vr_fr-vr_to]-im*[vi_fr-vi_to])
s_fr = (vr_fr+im*vi_fr).*([G*vr_fr-G*vr_to-B*vi_fr+B*vi_to]-im*[G*vi_fr-G*vi_to+B*vr_fr-B*vr_to])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L546-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Matrix{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real, Matrix{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Matrix{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s2960&quot;} where var&quot;#s2960&quot;&lt;:Real, Matrix{var&quot;#s2959&quot;} where var&quot;#s2959&quot;&lt;:Real, Matrix{var&quot;#s2958&quot;} where var&quot;#s2958&quot;&lt;:Real, Matrix{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p><pre><code class="language-none">p_fr ==     g[c,c] * vm_fr[c]^2 +
            sum( g[c,d]*vm_fr[c]*vm_fr[d]*cos(va_fr[c]-va_fr[d]) +
                 b[c,d]*vm_fr[c]*vm_fr[d]*sin(va_fr[c]-va_fr[d]) for d in conductor_ids(pm) if d != c) +
            sum(-g[c,d]*vm_fr[c]*vm_to[d]*cos(va_fr[c]-va_to[d]) +
                -b[c,d]*vm_fr[c]*vm_to[d]*sin(va_fr[c]-va_to[d]) for d in conductor_ids(pm))
            + g_fr[c,c] * vm_fr[c]^2 +
            sum( g_fr[c,d]*vm_fr[c]*vm_fr[d]*cos(va_fr[c]-va_fr[d]) +
                 b_fr[c,d]*vm_fr[c]*vm_fr[d]*sin(va_fr[c]-va_fr[d]) for d in conductor_ids(pm) if d != c)
            )
q_fr == -b[c,c] *vm_fr[c]^2 -
            sum( b[c,d]*vm_fr[c]*vm_fr[d]*cos(va_fr[c]-va_fr[d]) -
                 g[c,d]*vm_fr[c]*vm_fr[d]*sin(va_fr[c]-va_fr[d]) for d in conductor_ids(pm) if d != c) -
            sum(-b[c,d]*vm_fr[c]*vm_to[d]*cos(va_fr[c]-va_to[d]) +
                 g[c,d]*vm_fr[c]*vm_to[d]*sin(va_fr[c]-va_to[d]) for d in conductor_ids(pm))
            -b_fr[c,c] *vm_fr[c]^2 -
            sum( b_fr[c,d]*vm_fr[c]*vm_fr[d]*cos(va_fr[c]-va_fr[d]) -
                 g_fr[c,d]*vm_fr[c]*vm_fr[d]*sin(va_fr[c]-va_fr[d]) for d in conductor_ids(pm) if d != c)
            )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L632-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints</p><p>s<em>fr = v</em>fr.<em>conj(Y</em>(v<em>fr-v</em>to)) s<em>fr = (vr</em>fr+im<em>vi_fr).</em>(G-im<em>B)</em>([vr<em>fr-vr</em>to]-im<em>[vi<em>fr-vi</em>to]) s<em>fr = (vr</em>fr+im</em>vi<em>fr).<em>([G</em>vr</em>fr-G<em>vr_to-B</em>vi<em>fr+B*vi</em>to]-im<em>[G</em>vi<em>fr-G*vi</em>to+B<em>vr_fr-B</em>vr_to])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L741-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Matrix{var&quot;#s2968&quot;} where var&quot;#s2968&quot;&lt;:Real, Matrix{var&quot;#s2967&quot;} where var&quot;#s2967&quot;&lt;:Real, Matrix{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Matrix{var&quot;#s2968&quot;} where var&quot;#s2968&quot;&lt;:Real, Matrix{var&quot;#s2967&quot;} where var&quot;#s2967&quot;&lt;:Real, Matrix{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p><pre><code class="language-none">p[f_idx] == -b*(t[f_bus] - t[t_bus])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/dcp.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ohms_yt_from(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for ohms constraint for branches on the from-side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L443-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedWModels, Int64, Int64, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{AbstractUnbalancedWModels, Int64, Int64, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real, Matrix{var&quot;#s2964&quot;} where var&quot;#s2964&quot;&lt;:Real, Matrix{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real, Matrix{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real, Matrix{var&quot;#s2964&quot;} where var&quot;#s2964&quot;&lt;:Real, Matrix{var&quot;#s2963&quot;} where var&quot;#s2963&quot;&lt;:Real, Matrix{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ohms_yt_from(pm::FOTPUPowerModel, nw::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, G::Matrix{&lt;:Real}, B::Matrix{&lt;:Real}, G_fr::Matrix{&lt;:Real}, B_fr::Matrix{&lt;:Real})</code></pre><p>Ohm constraints similar to ACPUPowerModel. The nonlinear functions are approximated around initial operating points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotp.jl#L195-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Matrix{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Matrix{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real, Matrix{var&quot;#s2954&quot;} where var&quot;#s2954&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s2957&quot;} where var&quot;#s2957&quot;&lt;:Real, Matrix{var&quot;#s2956&quot;} where var&quot;#s2956&quot;&lt;:Real, Matrix{var&quot;#s2955&quot;} where var&quot;#s2955&quot;&lt;:Real, Matrix{var&quot;#s2954&quot;} where var&quot;#s2954&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ohms_yt_from(pm::FOTRUPowerModel, nw::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, G::Matrix{&lt;:Real}, B::Matrix{&lt;:Real}, G_fr::Matrix{&lt;:Real}, B_fr::Matrix{&lt;:Real})</code></pre><p>Creates Ohms constraints by linearizing (similar to power balance constraints) around initial operating point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotr.jl#L387-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{NFAUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_from-Tuple{NFAUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage angle variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_ohms_yt_to(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	G::Matrix,
	B::Matrix,
	G_to::Matrix,
	B_to::Matrix
)</code></pre><p>For ACR models with explicit neutrals, creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form).</p><pre><code class="language-none">p[t_idx] ==  (g+g_to)*v[t_bus]^2 + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[t_bus]-t[f_bus])) + (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))
q[t_idx] == -(b+b_to)*v[t_bus]^2 - (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L599-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p><pre><code class="language-none">p[t_idx] ==  (g+g_to)*v[t_bus]^2 + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[t_bus]-t[f_bus])) + (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))
q[t_idx] == -(b+b_to)*v[t_bus]^2 - (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L686-L693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p><pre><code class="language-none">p[t_idx] ==  (g+g_to)*v[t_bus]^2 + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[t_bus]-t[f_bus])) + (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))
q[t_idx] == -(b+b_to)*v[t_bus]^2 - (-b*tr+g*ti)/tm*(v[t_bus]*v[f_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr-b*ti)/tm*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L773-L780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Do nothing, this model is symmetric</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ohms_yt_to(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for ohms constraint for branches on the to-side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L462-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedWModels, Int64, Int64, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{AbstractUnbalancedWModels, Int64, Int64, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ohms_yt_to(pm::FOTPUPowerModel, nw::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, G::Matrix{&lt;:Real}, B::Matrix{&lt;:Real}, G_to::Matrix{&lt;:Real}, B_to::Matrix{&lt;:Real})</code></pre><p>Ohm constraints similar to ACPUPowerModel. The nonlinear functions are approximated around initial operating points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotp.jl#L277-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_ohms_yt_to(pm::FOTRUPowerModel, nw::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, G::Matrix, B::Matrix, G_to::Matrix, B_to::Matrix)</code></pre><p>Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotr.jl#L435-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{NFAUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_ohms_yt_to-Tuple{NFAUPowerModel, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Matrix{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Matrix{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_ohms_yt_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, this model is symmetric</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_oltc_tap_fix-Tuple{AbstractUnbalancedPowerModel, Int64, Vector{T} where T, Vector{T} where T}" href="#PowerModelsDistribution.constraint_mc_oltc_tap_fix-Tuple{AbstractUnbalancedPowerModel, Int64, Vector{T} where T, Vector{T} where T}"><code>PowerModelsDistribution.constraint_mc_oltc_tap_fix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For a variable tap transformer, fix the tap variables which are fixed. For example, an OLTC where the third phase is fixed, will have tap variables for all phases, but the third tap variable should be fixed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance(pm::AbstractUnbalancedActivePowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>power balanace constraint with line shunts and transformers, active power only</p><p class="math-container">\[p_{br} + p_{tr} + p_{sw} == p_{g} - p_{s} - p_{d} - G\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L76-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance(pm::FBSUBFPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints similar to ACRUPowerModel with shunt current calculated using initial operating point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{FOTPUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{FOTPUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance(pm::FOTPUPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance equations similar to ACPUPowerModel. The nonlinear functions are approximated around initial operating point.</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating points: }  v_{m0}^{t} \angle v_{a0}^t,~v_{m0}^u \angle v_{a0}^u\\
&amp; {v_m^t}^2 \Rightarrow {v_{m0}^t}^2+2 \cdot v_{m0}^t \cdot (v_m^t-v_{m0}^t)\\
&amp; v_m^t \cdot v_m^u \cdot \cos(v_a^t-v_a^u) \Rightarrow v_{m0}^t \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u) +
\begin{bmatrix}
v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u) \\
v_{m0}^t \cdot \cos(v_{a0}^t-v_{a0}^u) \\
-v_{m0}^t \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u) \\
v_{m0}^t \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u)
\end{bmatrix}^\top
\begin{bmatrix}
v_m^t-v_{m0}^t \\
v_m^u-v_{m0}^u \\
v_a^t-v_{a0}^t \\
v_a^u-v_{a0}^u
\end{bmatrix} \\
&amp; v_m^t \cdot v_m^u \cdot \sin(v_a^t-v_a^u) \Rightarrow v_{m0}^t \cdot v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u) +
\begin{bmatrix}
v_{m0}^u \cdot \sin(v_{a0}^t-v_{a0}^u) \\
v_{m0}^t \cdot \sin(v_{a0}^t-v_{a0}^u) \\
v_{m0}^t \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u) \\
-v_{m0}^t \cdot v_{m0}^u \cdot \cos(v_{a0}^t-v_{a0}^u)
\end{bmatrix}^\top
\begin{bmatrix}
v_m^t-v_{m0}^t \\
v_m^u-v_{m0}^u \\
v_a^t-v_{a0}^t \\
v_a^u-v_{a0}^u
\end{bmatrix}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotp.jl#L54-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{FOTRUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{FOTRUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance(pm::FOTRUPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints similar to ACRUPowerModel with shunt current linearized around initial operating point.</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating point: }  (v_{r0} + j ⋅ v_{i0})\\
&amp; v_{r} ⋅ v_{i} = v_{r0} ⋅ v_{i0} + v_{r} ⋅ v_{i0} + v_{r0} ⋅ v_{i} - 2 ⋅ v_{r0} ⋅ v_{i0}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotr.jl#L108-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_lin.jl#L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{SDPUBFKCLMXModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{SDPUBFKCLMXModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shunt handling in matrix form: I = Y.U S = U.I&#39; = U.(Y.U)&#39; = U.U&#39;.Y&#39; = W.Y&#39;   = (Wr+j.Wi)(G+jB)&#39; = (Wr+j.Wi)(G&#39;-j.B&#39;) = (Wr.G&#39;+Wi.B&#39;)+j(-Wr.B&#39;+Wi.G&#39;) P =  Wr.G&#39;+Wi.B&#39; Q = -Wr.B&#39;+Wi.G&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L869-L876">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_power_balance(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	terminals::Vector{Int},
	grounded::Vector{Bool},
	bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
	bus_gens::Vector{Tuple{Int,Vector{Int}}},
	bus_storage::Vector{Tuple{Int,Vector{Int}}},
	bus_loads::Vector{Tuple{Int,Vector{Int}}},
	bus_shunts::Vector{Tuple{Int,Vector{Int}}}
)</code></pre><p>Imposes power balance constraints at each ungrounded terminal of bus <code>i</code> for rectangular voltage models with explicit neutrals. <code>sum(p + im*q) = 0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_shared.jl#L161-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance_capc(pm::AbstractUnbalancedACPModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control.</p><p class="math-container">\[\begin{align}
    &amp; Bs = z ⋅ bs, \\
    &amp;\text{capacitor ON: }  z = 1, \\
    &amp;\text{capacitor OFF: } z = 0.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L449-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance_capc(pm::AbstractUnbalancedACRModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control.</p><p class="math-container">\[\begin{align}
    &amp; Bt = z ⋅ bs, \\
    &amp;\text{capacitor ON: }  z = 1, \\
    &amp;\text{capacitor OFF: } z = 0.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L520-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance_capc(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for KCL constraints with capacitor control variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L349-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance_capc(pm::FBSUBFPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control similar to ACRUPowerModel with shunt current calculated using initial operating point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L352-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{FOTRUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{FOTRUPowerModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance_capc(pm::FOTRUPowerModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control with shunt current calculated using initial operating point.</p><p class="math-container">\[\begin{align}
    &amp; B_t = b_s ⋅ z,~~ cq_{sh} = B_t ⋅ v, \\
    &amp;\text{FOT approximation: }  B_t ⋅ v_r ⋅ v_i = B_{t0} ⋅ v_{r0} ⋅ v_{i0} + B_{t} ⋅ v_{r0} ⋅ v_{i0} + B_{t0} ⋅ v_{r} ⋅ v_{i0} + B_{t0} ⋅ v_{r0} ⋅ v_{i} - 3 ⋅ B_{t0} ⋅ v_{r0} ⋅ v_{i0}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotr.jl#L193-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_capc-Tuple{LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_capc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance_capc(pm::LPUBFDiagModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>Power balance constraints with capacitor control linearized using McCormick envelopes</p><p class="math-container">\[\begin{align}
    &amp; B_s = b_s ⋅ z,~~ cq_{sh} = B_s ⋅ w, \\
    &amp;\text{Underestimator: }  cq_{sh} ≥ B_s ⋅ w_\text{min},~~ cq_{sh} ≥ b_s ⋅ w  + B_s ⋅ w_\text{max} - b_s ⋅ w_\text{max}\\
    &amp;\text{Overestimator: }   cq_{sh} ≤ B_s ⋅ w_\text{max},~~ cq_{sh} ≤ b_s ⋅ w  + B_s ⋅ w_\text{min} - b_s ⋅ w_\text{min}\\
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_lin.jl#L166-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>power balance constraint with line shunts and transformers for load shed problem, DCP formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/dcp.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance_shed(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints for load shed problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L321-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>KCL for load shed problem with transformers (AbstractWForms)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_shed_simple-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_shed_simple-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_shed_simple</code></a> — <span class="docstring-category">Method</span></header><section><div><p>power balance constraint with line shunts and transformers for load shed problem, DCP formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/dcp.jl#L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_simple</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_simple</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_balance_simple-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_balance_simple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance_simple(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints for simple load shedding</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L293-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_slack</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_slack</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_balance_slack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_balance_slack(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for KCL constraints which include a slack power at every bus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L265-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{var&quot;#s2937&quot;} where var&quot;#s2937&quot;&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}, Vector{var&quot;#s790&quot;} where var&quot;#s790&quot;&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}, Vector{var&quot;#s788&quot;} where var&quot;#s788&quot;&lt;:Tuple{Int64, Vector{Union{Int64, String}}}, Vector{var&quot;#s787&quot;} where var&quot;#s787&quot;&lt;:Tuple{Int64, Vector{Union{Int64, String}}}, Vector{var&quot;#s786&quot;} where var&quot;#s786&quot;&lt;:Tuple{Int64, Vector{Union{Int64, String}}}, Vector{var&quot;#s785&quot;} where var&quot;#s785&quot;&lt;:Tuple{Int64, Vector{Union{Int64, String}}}}" href="#PowerModelsDistribution.constraint_mc_power_balance_slack-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{var&quot;#s2937&quot;} where var&quot;#s2937&quot;&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}, Vector{var&quot;#s790&quot;} where var&quot;#s790&quot;&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Tuple{Tuple{Int64, Int64, Int64}, Vector{Union{Int64, String}}}, Vector{var&quot;#s788&quot;} where var&quot;#s788&quot;&lt;:Tuple{Int64, Vector{Union{Int64, String}}}, Vector{var&quot;#s787&quot;} where var&quot;#s787&quot;&lt;:Tuple{Int64, Vector{Union{Int64, String}}}, Vector{var&quot;#s786&quot;} where var&quot;#s786&quot;&lt;:Tuple{Int64, Vector{Union{Int64, String}}}, Vector{var&quot;#s785&quot;} where var&quot;#s785&quot;&lt;:Tuple{Int64, Vector{Union{Int64, String}}}}"><code>PowerModelsDistribution.constraint_mc_power_balance_slack</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_losses-Tuple{AbstractUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Matrix{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real, Matrix{var&quot;#s2970&quot;} where var&quot;#s2970&quot;&lt;:Real, Matrix{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Matrix{var&quot;#s2968&quot;} where var&quot;#s2968&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_power_losses-Tuple{AbstractUBFModels, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Matrix{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Matrix{var&quot;#s2971&quot;} where var&quot;#s2971&quot;&lt;:Real, Matrix{var&quot;#s2970&quot;} where var&quot;#s2970&quot;&lt;:Real, Matrix{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Matrix{var&quot;#s2968&quot;} where var&quot;#s2968&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_power_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines branch flow model power flow equations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_losses-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_power_losses-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_power_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_losses(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for constraints for modeling power losses across branches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L523-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_losses-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s2970&quot;} where var&quot;#s2970&quot;&lt;:Real, Matrix{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Matrix{var&quot;#s2968&quot;} where var&quot;#s2968&quot;&lt;:Real, Matrix{var&quot;#s2967&quot;} where var&quot;#s2967&quot;&lt;:Real, Matrix{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Matrix{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_power_losses-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s2970&quot;} where var&quot;#s2970&quot;&lt;:Real, Matrix{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Matrix{var&quot;#s2968&quot;} where var&quot;#s2968&quot;&lt;:Real, Matrix{var&quot;#s2967&quot;} where var&quot;#s2967&quot;&lt;:Real, Matrix{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Matrix{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_power_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_power_losses(pm::FBSUBFPowerModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, r::Matrix{&lt;:Real}, x::Matrix{&lt;:Real}, g_sh_fr::Matrix{&lt;:Real}, g_sh_to::Matrix{&lt;:Real}, b_sh_fr::Matrix{&lt;:Real}, b_sh_to::Matrix{&lt;:Real})</code></pre><p>Branch flow model power flow equation linearized around initial operating point (backward sweep)</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating points: }  (v_{r0}^{fr} + j ⋅ v_{i0}^{fr}),~ (v_{r0}^{to} + j ⋅ v_{i0}^{to})\\
&amp;\text{Voltage drop: }  v_{drop} = (v_{r0}^{fr} + j ⋅ v_{i0}^{fr}) - (v_{r0}^{to} + j ⋅ v_{i0}^{to}),\\
&amp;\text{Line series admittance: } y = (r+j ⋅ x)^{-1},\\
&amp;\text{Power loss: }  s_{loss} = v_{drop} ⋅ (y ⋅ v_{drop})^*,\\
&amp;\text{Active power flow: }  p^{fr} + p^{to} = g_{sh}^{fr} ⋅ {(v_{m0}^{fr})}^2 +  g_{sh}^{to} ⋅ {(v_{m0}^{to})}^2 + \Re(s_{loss}),\\
&amp;\text{Reactive power flow: }  q^{fr} + q^{to} = -b_{sh}^{fr} ⋅ {(v_{m0}^{fr})}^2 -  b_{sh}^{to} ⋅ {(v_{m0}^{to})}^2 + \Im(s_{loss}).
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L151-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_power_losses-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s2970&quot;} where var&quot;#s2970&quot;&lt;:Real, Matrix{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Matrix{var&quot;#s2968&quot;} where var&quot;#s2968&quot;&lt;:Real, Matrix{var&quot;#s2967&quot;} where var&quot;#s2967&quot;&lt;:Real, Matrix{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Matrix{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_power_losses-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Matrix{var&quot;#s2970&quot;} where var&quot;#s2970&quot;&lt;:Real, Matrix{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Matrix{var&quot;#s2968&quot;} where var&quot;#s2968&quot;&lt;:Real, Matrix{var&quot;#s2967&quot;} where var&quot;#s2967&quot;&lt;:Real, Matrix{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Matrix{var&quot;#s2965&quot;} where var&quot;#s2965&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_power_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Defines branch flow model power flow equations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_lin.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_regen_setpoint_active-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Any}" href="#PowerModelsDistribution.constraint_mc_regen_setpoint_active-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Any}"><code>PowerModelsDistribution.constraint_mc_regen_setpoint_active</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>qq[i] == qq</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_storage_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1055">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_storage_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_current_limit-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_storage_current_limit(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for storage current limit constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L913-L917">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUBFModels, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUBFModels, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Neglects the active and reactive loss terms associated with the squared current magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_lin.jl#L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedACRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedACRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L1064">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Any, Vector{Int64}, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Real, Real}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Any, Vector{Int64}, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Real, Real}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_losses-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_storage_losses(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for storage loss constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L888-L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Any, Any}" href="#PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Any, Any}"><code>PowerModelsDistribution.constraint_mc_storage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Any, Any}" href="#PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Any, Any}"><code>PowerModelsDistribution.constraint_mc_storage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_storage_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Tempate function for storage on/off constraints for MLD problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L925-L929">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_storage_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_storage_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_storage_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_storage_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_storage_thermal_limit(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for storage thermal limit constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L901-L905">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedACPModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_switch_ampacity(pm::AbstractUnbalancedACPModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on switches</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq vm_{fr}^2 i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1304-L1312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_switch_ampacity(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for switch current limit constraint from-side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L1066-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedRectangularModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_switch_ampacity(pm::AbstractUnbalancedRectangularModels, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on switches</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq (vr_{fr}^2 + vi_{fr}^2) i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L1171-L1179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_switch_ampacity-Tuple{AbstractUnbalancedWModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_switch_ampacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_switch_ampacity(pm::AbstractUnbalancedWModels, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, c_rating::Vector{&lt;:Real})::Nothing</code></pre><p>ACP current limit constraint on switches from-side</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq w_{fr} i_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L428-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_current-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_switch_current(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int};
	report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, create expressions for the terminal current flows <code>:crsw_bus</code> and <code>cisw_bus</code>, and link the from-side to the to-side switch current</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1648-L1663">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_current-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_switch_current(
    pm::ExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    report::Bool=true
)</code></pre><p>For models with explicit neutrals, link the switch currents or create appropiate expressions for them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template_en.jl#L187-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_switch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_switch_current_limit(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the switch current magnitude per conductor. Note that a bound on the from-side implies the same bound on the to-side current, so it suffices to apply this only explicitly at the from-side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L788-L801">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_switch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_switch_current_limit(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>For IVR models with explicit neutrals, imposes a bound on the switch current magnitude per conductor. Note that a bound on the from-side implies the same bound on the to-side current, so it suffices to apply this only explicitly at the from-side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1680-L1693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_switch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_current_limit-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_current_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_switch_current_limit(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for switch current limit constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L188-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_power-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_power-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_switch_power(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int};
	report::Bool=true
)</code></pre><p>constraint<em>mc</em>switch<em>power(     pm::ReducedExplicitNeutralIVRModels,     nw::Int,     id::Int,     f</em>idx::Tuple{Int,Int,Int},     t<em>idx::Tuple{Int,Int,Int},     f</em>connections::Vector{Int},     t_connections::Vector{Int};     report::Bool=true )</p><p>For IVR models with explicit neutrals, create expressions for the terminal power flows <code>:psw_bus</code> and <code>qsw_bus</code>, and link the from-side to the to-side switch power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L745-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_power-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_switch_power(
    pm::ExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    report::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, link the switch power or create appropiate expressions for them</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template_en.jl#L165-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_power_on_off-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_power_on_off-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_power_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L718">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_power_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_power_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_state-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_switch_state(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for switch state constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedDCPModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/dcp.jl#L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedNFAModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedNFAModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedWModels, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{AbstractUnbalancedWModels, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_closed-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_closed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_switch_state_closed(pm::FBSUBFPowerModel, nw::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})</code></pre><p>Voltage constraints for closed switches similar to ACRUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L614-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_state_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_switch_state_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default, relax::Bool=false)::Nothing</code></pre><p>Template function for switch state on/off constraints (MLD problems)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedWModels, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_on_off-Tuple{AbstractUnbalancedWModels, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_open-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_open-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_open</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L656">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_state_open-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}}" href="#PowerModelsDistribution.constraint_mc_switch_state_open-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}}"><code>PowerModelsDistribution.constraint_mc_switch_state_open</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_switch_thermal_limit(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the switch power magnitude per conductor. Note that a bound on the from-side implies the same bound on the to-side power when the switch is closed (equal voltages), and also when it is open since the power then equals zero on both ends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L821-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractLPUBFModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractLPUBFModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Float64}}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_switch_thermal_limit(
	pm::AbstractNLExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>This method is not yet implemented for AbstractLPUBFModel. If the limit is finite, a warning is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_lin.jl#L469-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_switch_thermal_limit(
	pm::AbstractNLExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>For IVR models with explicit neutrals, imposes a bound on the switch power magnitude per conductor. Note that a bound on the from-side implies the same bound on the to-side power when the switch is closed (equal voltages), and also when it is open since the power then equals zero on both ends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1711-L1725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_switch_thermal_limit(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rating::Vector{&lt;:Real}
)</code></pre><p>For quadratic IVR models with explicit neutrals, throw an error because this cannot be represented quadratically without introducing explicit power variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1748-L1760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_switch_thermal_limit(pm::AbstractUnbalancedActivePowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, rating::Vector{&lt;:Real})::Nothing</code></pre><p>Active power only switch thermal limit constraint</p><p>math<code>-S_{max} \leq p_{fr} \leq S_{max}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L232-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_switch_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_switch_thermal_limit(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for switch thermal limit constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_thermal_limit_from(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the from-side line power magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L666-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_thermal_limit_from(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For IVR models with explicit neutrals, imposes a bound on the from-side line power magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1425-L1436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_thermal_limit_from(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	f_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For quadratic IVR models with explicit neutrals, throw an error because this cannot be represented quadratically without introducing explicit power variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1485-L1497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>-rate_a &lt;= p[f_idx] &lt;= rate_a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>p[f_idx]^2 + q[f_idx]^2 &lt;= rate_a^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_thermal_limit_from(pm::AbstractUnbalancedPowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, rate_a::Vector{&lt;:Real})::Nothing</code></pre><p>Generic thermal limit constraint for branches (from-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_from-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_thermal_limit_from(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for branch thermal constraints (from-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L563-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractExplicitNeutralACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_thermal_limit_to(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	t_idx::Tuple{Int,Int,Int},
	t_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the from-side line power magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L692-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_thermal_limit_to(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	t_idx::Tuple{Int,Int,Int},
	t_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For IVR models with explicit neutrals, imposes a bound on the to-side line power magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1454-L1465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_thermal_limit_to(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	t_idx::Tuple{Int,Int,Int},
	t_connections::Vector{Int},
	rate_a::Vector{&lt;:Real}
)</code></pre><p>For quadratic IVR models with explicit neutrals, throw an error because this cannot be represented quadratically without introducing explicit power variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1507-L1519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedActivePowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedIVRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>p[t_idx]^2 + q[t_idx]^2 &lt;= rate_a^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_thermal_limit_to(pm::AbstractUnbalancedPowerModel, nw::Int, t_idx::Tuple{Int,Int,Int}, t_connections::Vector{Int}, rate_a::Vector{&lt;:Real})::Nothing</code></pre><p>Generic thermal limit constraint for branches (to-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_thermal_limit_to-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_thermal_limit_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_thermal_limit_to(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for branch thermal constraints (to-side)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L583-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates phase angle constraints at reference buses</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedPolarModels, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedPolarModels, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates phase angle constraints at reference buses</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_theta_ref(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for reference angle constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedWModels, Int64, Int64, Any}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedWModels, Int64, Int64, Any}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>do nothing, no way to represent this in these variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_theta_ref(pm::FBSUBFPowerModel, nw::Int, i::Int, va_ref::Vector{&lt;:Real})</code></pre><p>Creates phase angle constraints at reference buses similar to ACRUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L248-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{LPUBFDiagModel, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{LPUBFDiagModel, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>balanced three-phase phasor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_lin.jl#L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{NFAUPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{NFAUPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage angle variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_theta_ref-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Vector{Int64}, Vector{Bool}}" href="#PowerModelsDistribution.constraint_mc_theta_ref-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Vector{Int64}, Vector{Bool}}"><code>PowerModelsDistribution.constraint_mc_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_theta_ref(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	va::Vector{&lt;:Real},
	terminals::Vector{Int},
	grounded::Vector{Bool}
)</code></pre><p>Creates phase angle constraints at bus <code>i</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_shared.jl#L356-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}" href="#PowerModelsDistribution.constraint_mc_transformer_current-Tuple{AbstractExplicitNeutralIVRModel, Int64}"><code>PowerModelsDistribution.constraint_mc_transformer_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_current(
	pm::AbstractExplicitNeutralIVRModel,
	i::Int;
	nw::Int=nw_id_default,
	fix_taps::Bool=true
)</code></pre><p>For IVR models with explicit neutrals, links the current variables of the from-side and to-side transformer windings, and creates expressions for the terminal current flows</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L918-L929">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_current_dy-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_current_dy-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_current_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_current_dy(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For IVR models with explicit neutrals, links the current variables of the from-side and to-side transformer windings, and creates expressions for the terminal current flows for delta-wye connected transformers</p><pre><code class="language-none">scale*cr_fr_P + cr_to_P == 0
scale*ci_fr_P + ci_to_P == 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1009-L1035">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_current_yy-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_current_yy-Tuple{AbstractExplicitNeutralIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_current_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_current_yy(
	pm::AbstractExplicitNeutralIVRModel,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For IVR models with explicit neutrals, links the current variables of the from-side and to-side transformer windings, and creates expressions for the terminal current flows for wye-wye connected transformers</p><pre><code class="language-none">scale*cr_fr_P + cr_to_P == 0
scale*ci_fr_P + ci_to_P == 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L962-L988">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_transformer_power-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_transformer_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_transformer_power(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default, fix_taps::Bool=true)::Nothing</code></pre><p>Template function for Transformer constraints in Power-voltage space, considering winding type, conductor order, polarity and tap settings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L663-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power-Tuple{NFAUPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_transformer_power-Tuple{NFAUPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_transformer_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_transformer_power(pm::NFAUPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>transformer active power only constraint pf=-pt</p><p class="math-container">\[p_f[fc] == -pt[tc]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L158-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_power_dy(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For ACR models with explicit neutrals, links the from-side and to-side power variables of delta-wye connected transformers. Expressions for the terminal power flow variables are also added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L401-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds all constraints required to model a two-winding, delta-wye connected transformer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L1009">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delta-wye transformer power constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_transformer_power_dy(pm::FBSUBFPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, delta-wye connected transformer similar to ACRUPowerModel with power constraints using initial operating point voltage instead of actual voltage variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L709-L714">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2966&quot;} where var&quot;#s2966&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_transformer_power_dy(pm::FOTPUPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, delta-wye connected transformer similar to ACPUPowerModel with voltage constraints linearized using first-order Taylor approximation and power constraints simplified using initial operating point voltage instead of actual voltage variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotp.jl#L347-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_dy-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_transformer_power_dy(pm::FOTRUPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, delta-wye connected transformer similar to ACRUPowerModel with power constraints using initial operating point voltage instead of actual voltage variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotr.jl#L622-L627">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s2962&quot;} where var&quot;#s2962&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_power_yy(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For ACR models with explicit neutrals, links the from-side and to-side power variables of wye-wye connected transformers. Expressions for the terminal power flow variables are also added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L314-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds all constraints required to model a two-winding, wye-wye connected transformer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L954">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{AbstractUnbalancedIVRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>wye-wye transformer power constraint for IVR formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FBSUBFPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_transformer_power_yy(pm::FBSUBFPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, wye-wye connected transformer similar to ACRUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L633-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FOTPUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_transformer_power_yy(pm::FOTPUPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, wye-wye connected transformer similar to ACPUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotp.jl#L288-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{FOTRUPowerModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_transformer_power_yy(pm::FOTRUPowerModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)</code></pre><p>Add all constraints required to model a two-winding, wye-wye connected transformer similar to ACRUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotr.jl#L546-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_power_yy-Tuple{LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_power_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Links to and from power and voltages in a wye-wye transformer, assumes tm_fixed is true</p><p class="math-container">\[w_fr_i=(pol_i*tm_scale*tm_i)^2w_to_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector{T} where T, Vector{T} where T, ConnConfig, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractExplicitNeutralACRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector{T} where T, Vector{T} where T, ConnConfig, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_thermal_limit(
	pm::AbstractExplicitNeutralACRModel,
	nw::Int,
	id::Int,
	f_idx::Tuple,
	t_idx::Tuple,
	f_bus::Int,
	t_bus::Int,
	f_connections::Vector,
	t_connections::Vector,
	config::ConnConfig,
	sm_ub::Real;
	report::Bool=true
)</code></pre><p>For ACR models with explicit neutrals, imposes a bound on the magnitude of the total apparent power at each winding of the transformer.</p><pre><code class="language-none">sum(pt_fr)^2 + sum(qt_fr)^2 &lt;= sm_ub^2
sum(pt_to)^2 + sum(qt_to)^2 &lt;= sm_ub^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_acr.jl#L482-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector{T} where T, Vector{T} where T, ConnConfig, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractNLExplicitNeutralIVRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector{T} where T, Vector{T} where T, ConnConfig, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_thermal_limit(
	pm::AbstractNLExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	f_idx::Tuple,
	t_idx::Tuple,
	f_bus::Int,
	t_bus::Int,
	f_connections::Vector,
	t_connections::Vector,
	config::ConnConfig,
	sm_ub::Real;
	report::Bool=true
)</code></pre><p>For non-linear IVR models with explicit neutrals, imposes a bound on the magnitude of the total apparent power at both windings. Expressions are created for the transformer power variables.</p><pre><code class="language-none">sum(pt_fr)^2 + sum(qt_fr)^2 &lt;= sm_ub^2
sum(pt_to)^2 + sum(qt_to)^2 &lt;= sm_ub^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1059-L1083">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector{T} where T, Vector{T} where T, ConnConfig, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{AbstractQuadraticExplicitNeutralIVRModel, Int64, Int64, Tuple, Tuple, Int64, Int64, Vector{T} where T, Vector{T} where T, ConnConfig, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_thermal_limit(
	pm::AbstractQuadraticExplicitNeutralIVRModel,
	nw::Int,
	id::Int,
	f_idx::Tuple,
	t_idx::Tuple,
	f_bus::Int,
	t_bus::Int,
	f_connections::Vector,
	t_connections::Vector,
	config::ConnConfig,
	sm_ub::Real;
	report::Bool=true
)</code></pre><p>For quadratic IVR models with explicit neutrals, imposes a bound on the magnitude of the total apparent power at both windings.</p><pre><code class="language-none">sum(pt_fr)^2 + sum(qt_fr)^2 &lt;= sm_ub^2
sum(pt_to)^2 + sum(qt_to)^2 &lt;= sm_ub^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_ivr.jl#L1137-L1160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_transformer_thermal_limit-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_transformer_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_thermal_limit(
	pm::ExplicitNeutralModels,
	id::Int;
	nw::Int=nw_id_default,
	bounded::Bool=true,
	report::Bool=true,
	kwargs...
)</code></pre><p>Imposes a bound on the total apparent at each transformer winding</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template_en.jl#L138-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_voltage-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_transformer_voltage-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_transformer_voltage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_voltage(
    pm::ExplicitNeutralModels,
    i::Int;
    nw::Int=nw_id_default,
    fix_taps::Bool=true
)</code></pre><p>For models with explicit neutrals, links the voltage of the from-side and to-side transformer windings</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template_en.jl#L99-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_voltage_dy-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_voltage_dy-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_voltage_dy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_voltage_dy(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For rectangular voltage models with explicit neutrals, links the voltage of the from-side and to-side transformer windings  for delta-wye connected transformers</p><pre><code class="language-none">Md*vr_fr_P == scale * (vr_to_P - vr_to_n)
Md*vi_fr_P == scale * (vi_to_P - vi_to_n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_shared.jl#L723-L748">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_transformer_voltage_yy-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real, Vector{Bool}, Real}" href="#PowerModelsDistribution.constraint_mc_transformer_voltage_yy-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real, Vector{Bool}, Real}"><code>PowerModelsDistribution.constraint_mc_transformer_voltage_yy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_transformer_voltage_yy(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	trans_id::Int,
	f_bus::Int,
	t_bus::Int,
	f_idx::Tuple{Int,Int,Int},
	t_idx::Tuple{Int,Int,Int},
	f_connections::Vector{Int},
	t_connections::Vector{Int},
	pol::Int,
	tm_set::Vector{&lt;:Real},
	tm_fixed::Vector{Bool},
	tm_scale::Real
)</code></pre><p>For rectangular voltage models with explicit neutrals, links the voltage of the from-side and to-side transformer windings  for wye-wye connected transformers</p><pre><code class="language-none">(vr_fr_P-vr_fr_n) == scale * (vr_to_P.-vr_to_n)
(vi_fr_P-vi_fr_n) == scale * (vi_to_P.-vi_to_n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_shared.jl#L678-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_absolute-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{var&quot;#s2970&quot;} where var&quot;#s2970&quot;&lt;:Real, Vector{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_absolute-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{var&quot;#s2970&quot;} where var&quot;#s2970&quot;&lt;:Real, Vector{var&quot;#s2969&quot;} where var&quot;#s2969&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_absolute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_voltage_absolute(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	terminals::Vector{Int},
	grounded::Vector{Bool},
	vmin::Vector{&lt;:Real},
	vmax::Vector{&lt;:Real};
	report::Bool=true
)</code></pre><p>Imposes absolute voltage magnitude bounds for models with explicit neutrals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_shared.jl#L244-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_absolute-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_absolute-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_absolute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_voltage_absolute(
    pm::RectangularVoltageExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    bounded::Bool=true,
    report::Bool=true,
    kwargs...
)</code></pre><p>Imposes absolute voltage magnitude bounds for models with explicit neutrals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template_en.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUBFModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUBFModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is duplicated at PowerModelsDistribution level to correctly handle the indexing of the shunts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedACRModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3042&quot;} where var&quot;#s3042&quot;&lt;:Real, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Any, Any}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedIVRModel, Int64, Any, Any, Any}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bounds the voltage angle difference between bus pairs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/ivr.jl#L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedNFAModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedNFAModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, these models do not have angle difference constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedPolarModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedPolarModels, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_voltage_angle_difference(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for constraints of the voltage angle difference across branches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L547-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{FBSUBFPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{FBSUBFPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_voltage_angle_difference(pm::FBSUBFPowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, angmin::Vector{&lt;:Real}, angmax::Vector{&lt;:Real})</code></pre><p>Nothing to do, this model ignores angle difference constraints&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{FOTRUPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_angle_difference-Tuple{FOTRUPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_voltage_angle_difference(pm::FOTRUPowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, angmin::Vector{&lt;:Real}, angmax::Vector{&lt;:Real})</code></pre><p>Nothing to do, this model ignores angle difference constraints&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotr.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_fixed-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real, Vector{Int64}, Vector{Bool}}" href="#PowerModelsDistribution.constraint_mc_voltage_fixed-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{var&quot;#s3546&quot;} where var&quot;#s3546&quot;&lt;:Real, Vector{var&quot;#s3474&quot;} where var&quot;#s3474&quot;&lt;:Real, Vector{Int64}, Vector{Bool}}"><code>PowerModelsDistribution.constraint_mc_voltage_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_voltage_fixed(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	vm::Vector{&lt;:Real},
	va::Vector{&lt;:Real},
	terminals::Vector{Int},
	grounded::Vector{Bool}
)</code></pre><p>Fixes the voltage variables at bus <code>i</code> to <code>vm.*exp.(im*va)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_shared.jl#L308-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>vmin &lt;= vm[i] &lt;= vmax</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_voltage_magnitude_bounds(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for voltage magnitude bounds constraints.</p><p>This constraint captures problem agnostic constraints that define limits for voltage magnitudes (where variable bounds cannot be used). Notable examples include IVRUPowerModel and ACRUPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L88-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{FBSUBFPowerModel, Int64, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_voltage_magnitude_bounds(pm::FBSUBFPowerModel, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})</code></pre><p>Upper voltage magnitude limits are linearized using outer approximation. Lower voltage magnitude limits are linearized around initial operating point.</p><p class="math-container">\[\begin{align}
&amp;\text{Initial operating point: } ⇒ v_{r}^0 + j ⋅ v_{i}^0~\text{where}~{(v_m^0)}^2 = {(v_{r}^0)}^2 + {(v_{i}^0)}^2\\
&amp;\text{Lower limits: }  2 ⋅ v_{r} ⋅ v_{r}^0 + 2 ⋅ v_{i} ⋅ v_{i}^0 - {(v_{m}^0)}^2 ≥ v_{min}^2,\\
&amp;\text{Upper limits: } -v_{max} ≤  v_{r} ≤ v_{max},\\
&amp; -v_{max} ≤  v_{i} ≤ v_{max},\\
&amp;-\sqrt{2} ⋅ v_{max} ≤  v_{r} + v_{i} ≤ \sqrt{2} ⋅ v_{max},\\
&amp; -\sqrt{2} ⋅ v_{max} ≤  v_{r} - v_{i} ≤ \sqrt{2} ⋅ v_{max}.
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_fbs.jl#L92-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{FOTRUPowerModel, Int64, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds-Tuple{FOTRUPowerModel, Int64, Int64, Vector{var&quot;#s3473&quot;} where var&quot;#s3473&quot;&lt;:Real, Vector{var&quot;#s3472&quot;} where var&quot;#s3472&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_voltage_magnitude_bounds(pm::FOTRUPowerModel, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})</code></pre><p>Linearized voltage magnitude limits similar to FBSUBFPowerModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/fotr.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_fixed-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real, Vector{Int64}, Vector{Bool}}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_fixed-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real, Vector{Int64}, Vector{Bool}}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_voltage_magnitude_fixed(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	vm::Vector{&lt;:Real},
	va::Vector{&lt;:Real},
	terminals::Vector{Int},
	grounded::Vector{Bool}
)</code></pre><p>Fixes the voltage variables at bus <code>i</code> to <code>vm.*exp.(im*va)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_shared.jl#L332-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedACPModel, Int64, Int64, Vector{var&quot;#s3041&quot;} where var&quot;#s3041&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_only</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>vm[i] == vmref</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1042">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedACRModel, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_only</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>vm[i] == vmref</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_only</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_only</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_mc_voltage_magnitude_only(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for voltage magnitude setpoint constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_mc_voltage_magnitude_only-Tuple{AbstractUnbalancedWModels, Int64, Int64, Vector{var&quot;#s3547&quot;} where var&quot;#s3547&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_mc_voltage_magnitude_only</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>vm[i] == vmref</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_pairwise-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{var&quot;#s2968&quot;} where var&quot;#s2968&quot;&lt;:Tuple{Any, Any, Real}, Vector{var&quot;#s2967&quot;} where var&quot;#s2967&quot;&lt;:Tuple{Any, Any, Real}}" href="#PowerModelsDistribution.constraint_mc_voltage_pairwise-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{var&quot;#s2968&quot;} where var&quot;#s2968&quot;&lt;:Tuple{Any, Any, Real}, Vector{var&quot;#s2967&quot;} where var&quot;#s2967&quot;&lt;:Tuple{Any, Any, Real}}"><code>PowerModelsDistribution.constraint_mc_voltage_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_voltage_pairwise(
	pm::RectangularVoltageExplicitNeutralModels,
	nw::Int,
	i::Int,
	terminals::Vector{Int},
	grounded::Vector{Bool},
	vm_pair_lb::Vector,
	vm_pair_ub::Vector;
	report::Bool=true
)</code></pre><p>Imposes pairwise voltage magnitude bounds, i.e. magnitude bounds on the voltage between to terminals, for models with explicit neutrals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/en_shared.jl#L276-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_pairwise-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_pairwise-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_voltage_pairwise(
    pm::RectangularVoltageExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    bounded::Bool=true,
    report::Bool=true,
    kwargs...
)</code></pre><p>Imposes pairwise voltage magnitude bounds, i.e. magnitude bounds on the voltage between to terminals, for models with explicit neutrals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template_en.jl#L20-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SDPUBFModel, Int64, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SDPUBFModel, Int64, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_psd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add explicit PSD-ness of W for nodes where it is not implied</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_sdp.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SOCConicUBFModel, Int64, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SOCConicUBFModel, Int64, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_psd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add explicit PSD-ness of W for nodes where it is not implied</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_soc.jl#L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SOCUBFModels, Int64, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_psd-Tuple{SOCUBFModels, Int64, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_psd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add explicit PSD-ness of W for nodes where it is not implied</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx_soc.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_mc_voltage_reference-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}" href="#PowerModelsDistribution.constraint_mc_voltage_reference-Tuple{Union{ExplicitNeutralModels, RectangularVoltageExplicitNeutralModels}, Int64}"><code>PowerModelsDistribution.constraint_mc_voltage_reference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function constraint_mc_voltage_reference(
    pm::ExplicitNeutralModels,
    id::Int;
    nw::Int=nw_id_default,
    bounded::Bool=true,
    report::Bool=true,
    kwargs...
)</code></pre><p>Imposes suitable constraints for the voltage at the reference bus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template_en.jl#L42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_pqw-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, Real, Real, Real, Real, Real, Real}" href="#PowerModelsDistribution.constraint_pqw-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, Real, Real, Real, Real, Real, Real}"><code>PowerModelsDistribution.constraint_pqw</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates the constraints modelling the (relaxed) voltage-dependency of the power consumed in each phase, s=p+jq. This is completely symmetrical for p and q, with appropriate substitutions of the variables and parameters: p-&gt;q, a-&gt;b, alpha-&gt;beta, pmin-&gt;qmin, pmax-&gt;qmax</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf_mx.jl#L589-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_complementarity_mi-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Float64, Float64}" href="#PowerModelsDistribution.constraint_storage_complementarity_mi-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Float64, Float64}"><code>PowerModelsDistribution.constraint_storage_complementarity_mi</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_complementarity_mi-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_storage_complementarity_mi-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_storage_complementarity_mi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_storage_complementarity_mi(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for mixed-integer storage complementarity constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L1011-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_complementarity_nl-Tuple{AbstractUnbalancedPowerModel, Int64, Int64}" href="#PowerModelsDistribution.constraint_storage_complementarity_nl-Tuple{AbstractUnbalancedPowerModel, Int64, Int64}"><code>PowerModelsDistribution.constraint_storage_complementarity_nl</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_complementarity_nl-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_storage_complementarity_nl-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_storage_complementarity_nl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_storage_complementarity_nl(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for nonlinear storage complementarity constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L1000-L1004">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUBFAModel, Int64, Any, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUBFAModel, Int64, Any, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Neglects the active and reactive loss terms associated with the squared current magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/bf.jl#L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUnbalancedACPModel, Int64, Any, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUnbalancedACPModel, Int64, Any, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acp.jl#L1233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUnbalancedACRModel, Int64, Any, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUnbalancedACRModel, Int64, Any, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/acr.jl#L1095">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Any, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUnbalancedAPLossLessModels, Int64, Any, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/dcp.jl#L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUnbalancedActivePowerModel, Int64, Any, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUnbalancedActivePowerModel, Int64, Any, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/apo.jl#L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUnbalancedWConvexModels, Int64, Any, Any, Any, Any, Any, Any}" href="#PowerModelsDistribution.constraint_storage_losses-Tuple{AbstractUnbalancedWConvexModels, Int64, Any, Any, Any, Any, Any, Any}"><code>PowerModelsDistribution.constraint_storage_losses</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/form/shared.jl#L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Float64, Float64, Float64}" href="#PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Float64, Float64, Float64}"><code>PowerModelsDistribution.constraint_storage_state</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64}" href="#PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64}"><code>PowerModelsDistribution.constraint_storage_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_storage_state(pm::AbstractUnbalancedPowerModel, i::Int, nw_1::Int, nw_2::Int)::Nothing</code></pre><p>Template function for storage state constraints for multinetwork problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L974-L978">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsDistribution.constraint_storage_state-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsDistribution.constraint_storage_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_storage_state(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)::Nothing</code></pre><p>Template function for storage state constraints (non multinetwork)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint_template.jl#L954-L958">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_storage_state_initial-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Float64, Float64, Float64, Float64}" href="#PowerModelsDistribution.constraint_storage_state_initial-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Float64, Float64, Float64, Float64}"><code>PowerModelsDistribution.constraint_storage_state_initial</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.constraint_switch_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Real}" href="#PowerModelsDistribution.constraint_switch_thermal_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{var&quot;#s789&quot;} where var&quot;#s789&quot;&lt;:Real}"><code>PowerModelsDistribution.constraint_switch_thermal_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constraint_switch_thermal_limit(pm::AbstractUnbalancedPowerModel, nw::Int, f_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, rating::Vector{&lt;:Real})::Nothing</code></pre><p>Generic thermal limit constraint for switches (from-side)</p><p>math<code>p_{fr}^2 + q_{fr}^2 \leq S_{max}^2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/constraint.jl#L183-L191">source</a></section></article><h2 id="Relaxation-Helpers"><a class="docs-heading-anchor" href="#Relaxation-Helpers">Relaxation Helpers</a><a id="Relaxation-Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Relaxation-Helpers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.cut_complex_product_and_angle_difference-NTuple{7, Any}" href="#PowerModelsDistribution.cut_complex_product_and_angle_difference-NTuple{7, Any}"><code>PowerModelsDistribution.cut_complex_product_and_angle_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cut_complex_product_and_angle_difference(m, wf, wt, wr, wi, angmin, angmax)</code></pre><p>A valid inequality for the product of two complex variables with magnitude and angle difference bounds. In the literature this constraints are called the Lifted Nonlinear Cuts (LNCs). @misc{1512.04644,     Author = {Carleton Coffrin and Hassan Hijazi and Pascal Van Hentenryck},     Title = {Strengthening the SDP Relaxation of AC Power Flows with Convex         Envelopes, Bound Tightening, and Lifted Nonlinear Cuts},     Year = {2015},     Eprint = {arXiv:1512.04644}, }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/relaxation_scheme.jl#L195-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_psd_real-Tuple{Any, Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_psd_real-Tuple{Any, Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_psd_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relaxation_psd_to_psd_real(m, mxreal, mximag; ndim=3)</code></pre><p>For debugging / exploration: real-valued SDP to SDP relaxation based on PSDness of principal minors, default is 3x3 SDP relaxation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/relaxation_scheme.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc-Tuple{JuMP.Model, Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc-Tuple{JuMP.Model, Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relaxation_psd_to_soc(m::JuMP.Model, mxreal, mximag; complex::Bool=true)</code></pre><p>See section 4.3 for complex to real PSD constraint transformation: @article{Fazel2001, author = {Fazel, M. and Hindi, H. and Boyd, S.P.}, title = {{A rank minimization heuristic with application to minimum order system approximation}}, doi = {10.1109/ACC.2001.945730}, journal = {Proc. American Control Conf.}, number = {2}, pages = {4734–4739}, url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=945730}, volume = {6}, year = {2001} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/relaxation_scheme.jl#L113-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc_complex-Tuple{Any, Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc_complex-Tuple{Any, Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc_complex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relaxation_psd_to_soc_complex(m, mxreal, mximag)</code></pre><p>SDP to SOC relaxation of type 2, applied to complex-value matrix,  as described in:</p><pre><code class="language-none">@article{Kim2003,
author = {Kim, S and Kojima, M and Yamashita, M},
title = {{Second order cone programming relaxation of a positive semidefinite constraint}},
doi = {10.1080/1055678031000148696},
journal = {Optimization Methods and Software},
number = {5},
pages = {535--541},
volume = {18},
year = {2003}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/relaxation_scheme.jl#L29-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc_complex_conic-Tuple{Any, Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc_complex_conic-Tuple{Any, Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc_complex_conic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relaxation_psd_to_soc_complex_conic(m, mxreal, mximag)</code></pre><p>SDP to SOC relaxation of type 2, applied to complex-value matrix,  as described in:</p><pre><code class="language-none">@article{Kim2003,
author = {Kim, S and Kojima, M and Yamashita, M},
title = {{Second order cone programming relaxation of a positive semidefinite constraint}},
doi = {10.1080/1055678031000148696},
journal = {Optimization Methods and Software},
number = {5},
pages = {535--541},
volume = {18},
year = {2003}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/relaxation_scheme.jl#L85-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc_conic-Tuple{Any, Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc_conic-Tuple{Any, Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc_conic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relaxation_psd_to_soc_conic(m, mxreal, mximag; complex=true)</code></pre><p>See section 4.3 for complex to real PSD constraint transformation: @article{Fazel2001, author = {Fazel, M. and Hindi, H. and Boyd, S.P.}, title = {{A rank minimization heuristic with application to minimum order system approximation}}, doi = {10.1109/ACC.2001.945730}, journal = {Proc. American Control Conf.}, number = {2}, pages = {4734–4739}, url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=945730}, volume = {6}, year = {2001} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/relaxation_scheme.jl#L145-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc_real-Tuple{Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc_real-Tuple{Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relaxation_psd_to_soc_real(m, mx)</code></pre><p>SDP to SOC relaxation of type 2, applied to real-value matrix,  as described in:</p><pre><code class="language-none">@article{Kim2003,
author = {Kim, S and Kojima, M and Yamashita, M},
title = {{Second order cone programming relaxation of a positive semidefinite constraint}},
doi = {10.1080/1055678031000148696},
journal = {Optimization Methods and Software},
number = {5},
pages = {535--541},
volume = {18},
year = {2003}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/relaxation_scheme.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.relaxation_psd_to_soc_real_conic-Tuple{Any, Any}" href="#PowerModelsDistribution.relaxation_psd_to_soc_real_conic-Tuple{Any, Any}"><code>PowerModelsDistribution.relaxation_psd_to_soc_real_conic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relaxation_psd_to_soc_real_conic(m, mx)</code></pre><p>SDP to SOC relaxation of type 2, applied to real-value matrix,  as described in:</p><pre><code class="language-none">@article{Kim2003,
author = {Kim, S and Kojima, M and Yamashita, M},
title = {{Second order cone programming relaxation of a positive semidefinite constraint}},
doi = {10.1080/1055678031000148696},
journal = {Optimization Methods and Software},
number = {5},
pages = {535--541},
volume = {18},
year = {2003}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/relaxation_scheme.jl#L57-L73">source</a></section></article><h2 id="Miscellaneous-Helpers"><a class="docs-heading-anchor" href="#Miscellaneous-Helpers">Miscellaneous Helpers</a><a id="Miscellaneous-Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-Helpers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.calculate_tm_scale" href="#PowerModelsDistribution.calculate_tm_scale"><code>PowerModelsDistribution.calculate_tm_scale</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the tap scale factor for the non-dimensionalized equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/data.jl#L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.calc_branch_y" href="#PowerModelsDistribution.calc_branch_y"><code>PowerModelsDistribution.calc_branch_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_branch_y(branch::Dict{String,&lt;:Any})</code></pre><p>computes branch admittance matrices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/data.jl#L924-L928">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsDistribution.calc_buspair_parameters" href="#PowerModelsDistribution.calc_buspair_parameters"><code>PowerModelsDistribution.calc_buspair_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_buspair_parameters(buses, branches)</code></pre><p>Computes the buspair parameters for the network</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/4ac0879978ba0b23120d5850d22d4a96a92ab5cc/src/core/ref.jl#L167-L171">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="variables.html">« Variables</a><a class="docs-footer-nextpage" href="objectives.html">Objectives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 27 October 2021 19:58">Wednesday 27 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
